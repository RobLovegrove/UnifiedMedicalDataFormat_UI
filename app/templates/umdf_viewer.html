{% extends "base.html" %}

{% block title %}UMDF Viewer{% endblock %}

{% block content %}
<style>
    .dimension-controls input[type="range"] {
        -webkit-appearance: none !important;
        appearance: none !important;
        background: #343a40 !important;
        border-radius: 3px;
        height: 8px;
        outline: none;
        cursor: pointer;
        width: 150px;
        margin: 10px 0;
        border: none;
    }
    
    .dimension-controls input[type="range"]::-webkit-slider-track {
        -webkit-appearance: none !important;
        appearance: none !important;
        background: #343a40 !important;
        height: 8px;
        border-radius: 3px;
        border: none;
    }
    
    .dimension-controls input[type="range"]::-moz-range-track {
        background: #343a40 !important;
        height: 8px;
        border-radius: 3px;
        border: none;
    }
    
    .dimension-controls input[type="range"]::-ms-track {
        background: #343a40 !important;
        height: 8px;
        border-radius: 3px;
        border: none;
    }
    
    .dimension-controls input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        background: #007bff;
        border-radius: 50%;
        width: 18px;
        height: 18px;
        cursor: pointer;
        border: 2px solid #fff;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        margin-top: -5px;
    }
    
    .dimension-controls input[type="range"]::-moz-range-thumb {
        background: #007bff;
        border-radius: 50%;
        width: 18px;
        height: 18px;
        cursor: pointer;
        border: 2px solid #fff;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .dimension-controls input[type="range"]::-ms-thumb {
        background: #007bff;
        border-radius: 50%;
        width: 18px;
        height: 18px;
        cursor: pointer;
        border: 1px solid #adb5bd;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .dimension-controls input[type="range"]:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
    }
    
    .dimension-controls .form-label {
        font-weight: 500;
        color: #495057;
    }
    
    .dimension-controls .badge {
        font-size: 0.75em;
    }
    
    /* Custom Slider Styles */
    .custom-slider {
        position: relative;
        width: 150px;
        height: 20px;
        margin: 10px 0;
    }
    
    .slider-track {
        position: relative;
        width: 100%;
        height: 8px;
        background: #e9ecef;
        border-radius: 4px;
        cursor: pointer;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .slider-fill {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        border-radius: 4px;
        transition: width 0.05s ease-out;
        box-shadow: inset 0 1px 2px rgba(255,255,255,0.3);
    }
    
    .slider-thumb {
        position: absolute;
        top: -6px;
        width: 20px;
        height: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: 3px solid #fff;
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        transition: left 0.05s ease-out, transform 0.2s ease;
    }
    
    .slider-thumb:hover {
        background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
        transform: scale(1.15);
        box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
    }
</style>

<!-- Import Dialog Overlay -->
<div id="importDialog" class="position-fixed w-100 h-100 d-flex align-items-center justify-content-center" style="background-color: rgba(0, 0, 0, 0.5); z-index: 1050; top: 0; left: 0;">
    <div class="card" style="min-width: 400px;">
        <div class="card-body text-center p-5">
            <div class="spinner-border text-primary mb-3" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <h5 class="mb-3">Importing UMDF File</h5>
            
            <!-- File Details -->
            <div class="alert alert-info mb-3">
                <h6 class="mb-2"><i class="fas fa-file me-2"></i>File Details</h6>
                <p class="mb-1"><strong>Name:</strong> <span id="fileName"></span></p>
                <p class="mb-1"><strong>Size:</strong> <span id="fileSize"></span></p>
                <p class="mb-0"><strong>Type:</strong> Unified Medical Data Format</p>
            </div>
        </div>
    </div>
</div>

<!-- Main Content -->
<div class="container-fluid py-4">
    <!-- File Info Header -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-body position-relative">
                    <div class="position-absolute" style="top: 20px; right: 20px;">
                        <button class="btn btn-link text-muted p-0 me-3" onclick="importNewFile()" title="Import New File" style="border: none; background: none;">
                            <i class="fas fa-file-import" style="font-size: 1.5rem; transition: color 0.2s ease;" onmouseover="this.style.color='#28a745'" onmouseout="this.style.color='#6c757d'"></i>
                        </button>
                        <button class="btn btn-link text-muted p-0" onclick="clearFileCache()" title="Clear Cache & Import New File" style="border: none; background: none;">
                            <i class="fas fa-trash" style="font-size: 1.5rem; transition: color 0.2s ease;" onmouseover="this.style.color='#dc3545'" onmouseout="this.style.color='#6c757d'"></i>
                        </button>
                    </div>
                    <h4 class="card-title">
                        UMDF File Viewer
                    </h4>
                    {% if file_info.file_path %}
                        <p class="mb-2"><strong>File:</strong> {{ file_info.file_path }}</p>
                        <p class="mb-2"><strong>Size:</strong> {{ file_info.file_size }}</p>
                        <p class="mb-0"><strong>Modules Found:</strong> {{ file_info.module_count }}</p>
                    {% else %}
                        <p class="text-muted">No file loaded</p>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>


</div>

<script>
// Get file details from URL parameters and display them
document.addEventListener('DOMContentLoaded', function() {
    const urlParams = new URLSearchParams(window.location.search);
    const fileId = urlParams.get('file_id');
    const fileName = urlParams.get('name') || 'Unknown file';
    const fileSize = urlParams.get('size') || 'Unknown size';
    
    // Check if we have cached file data
    const cachedData = localStorage.getItem('umdf_file_data');
    if (cachedData) {
        try {
            const data = JSON.parse(cachedData);
            updatePageWithFileData(data, false); // Pass false to indicate not a new import
            // Hide the import dialog since we're using cached data
            document.getElementById('importDialog').style.display = 'none';
            return; // Exit early, don't process fileId
        } catch (e) {
            console.error('Error parsing cached data:', e);
            localStorage.removeItem('umdf_file_data');
        }
    }
    
    // Display file name and size in the dialog
    document.getElementById('fileName').textContent = fileName;
    document.getElementById('fileSize').textContent = fileSize;
    
    console.log('UMDF Viewer loaded - file ID:', fileId, 'Name:', fileName, 'Size:', fileSize);
    
    // If we have a file ID, retrieve the file content and send it to the server
    if (fileId) {
        const fileData = sessionStorage.getItem(fileId);
        if (fileData) {
            try {
                const parsedData = JSON.parse(fileData);
                console.log('Retrieved file data:', parsedData);
                
                // Send file content to server for processing
                sendFileToServer(parsedData, fileId);
                
            } catch (e) {
                console.error('Error parsing file data:', e);
                showError('Failed to parse file data');
                // Hide the import dialog on error
                document.getElementById('importDialog').style.display = 'none';
            }
        } else {
            console.error('No file data found for ID:', fileId);
            showError('File data not found. Please try importing again.');
            // Hide the import dialog on error
            document.getElementById('importDialog').style.display = 'none';
        }
    } else {
        // No file ID, hide the dialog immediately
        document.getElementById('importDialog').style.display = 'none';
    }
    
    // Remove the timeout - popup will close when file processing is complete
});

function sendFileToServer(fileData, fileId) {
    // Convert base64 data URL to binary
    const base64Data = fileData.content.split(',')[1];
    const binaryData = atob(base64Data);
    
    // Convert to Uint8Array
    const bytes = new Uint8Array(binaryData.length);
    for (let i = 0; i < binaryData.length; i++) {
        bytes[i] = binaryData.charCodeAt(i);
    }
    
    // Create FormData and send to server
    const formData = new FormData();
    formData.append('file', new Blob([bytes], { type: 'application/octet-stream' }), fileData.name);
    
    fetch('/umdf-viewer', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        console.log('Server response:', data);
        if (data.error) {
            showError(data.error);
        } else {
            // Update the page with the file data
            updatePageWithFileData(data, true); // Pass true to indicate a new import
        }
        // Clean up sessionStorage
        sessionStorage.removeItem('file_id');
    })
    .catch(error => {
        console.error('Error processing file:', error);
        // Only show error if this is an actual import attempt, not a page refresh
        if (sessionStorage.getItem('file_id')) {
            showError('Error processing file. Please try again.');
        }
        // Hide the import dialog
        const importDialog = document.getElementById('importDialog');
        if (importDialog) {
            importDialog.style.display = 'none';
        }
    });
}

function updatePageWithFileData(data, isNewImport) {
    console.log('Updating page with file data:', data);
    
    // Save the processed file data to localStorage for persistence
    try {
        localStorage.setItem('umdf_file_data', JSON.stringify(data));
        console.log('File data saved to localStorage');
    } catch (e) {
        console.error('Failed to save file data to localStorage:', e);
    }
    
    // Hide the import dialog
    const importDialog = document.getElementById('importDialog');
    if (importDialog) {
        importDialog.style.display = 'none';
        importDialog.style.visibility = 'hidden';
        importDialog.style.opacity = '0';
        importDialog.style.zIndex = '-1';
        
    } else {
        console.error('Import dialog element not found!');
        
        // Try alternative selectors
        const alternativeSelectors = [
            '.position-fixed',
            '[style*="z-index: 1050"]',
            '[style*="background-color: rgba(0, 0, 0, 0.5)"]'
        ];
        
        alternativeSelectors.forEach(selector => {
            const elements = document.querySelectorAll(selector);
            console.log(`Found ${elements.length} elements with selector: ${selector}`);
            elements.forEach(el => {
                if (el.style.position === 'fixed' || el.style.zIndex === '1050') {
                    console.log('Hiding element with alternative method:', el);
                    el.style.display = 'none';
                    el.style.visibility = 'hidden';
                    el.style.opacity = '0';
                    el.style.zIndex = '-1';
                }
            });
        });
    }
    
    // Update the file info header
    const fileInfoHeader = document.querySelector('.card-title').parentElement;
    if (data.file_path) {
        // Update the card content
        fileInfoHeader.innerHTML = `
            <div class="position-absolute" style="top: 20px; right: 20px;">
                <button class="btn btn-link text-muted p-0 me-3" onclick="importNewFile()" title="Import New File" style="border: none; background: none;">
                    <i class="fas fa-file-import" style="font-size: 1.5rem; transition: color 0.2s ease;" onmouseover="this.style.color='#28a745'" onmouseout="this.style.color='#6c757d'"></i>
                </button>
                <button class="btn btn-link text-muted p-0" onclick="clearFileCache()" title="Clear Cache & Import New File" style="border: none; background: none;">
                    <i class="fas fa-trash" style="font-size: 1.5rem; transition: color 0.2s ease;" onmouseover="this.style.color='#dc3545'" onmouseout="this.style.color='#6c757d'"></i>
                </button>
            </div>
            <h4 class="card-title">
                UMDF File Viewer
            </h4>
            <p class="mb-2"><strong>File:</strong> ${data.file_path}</p>
            <p class="mb-2"><strong>Size:</strong> ${data.file_size || 'Unknown'}</p>
            <p class="mb-0"><strong>Modules Found:</strong> ${data.module_count || 0}</p>
        `;
    }
    
    // Display modules if they exist
    if (data.modules && data.modules.length > 0) {
        const modulesContainer = document.createElement('div');
        modulesContainer.className = 'row';
        
        data.modules.forEach(module => {
            const moduleCard = document.createElement('div');
            moduleCard.className = 'col-12 mb-4';
            moduleCard.innerHTML = `
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title mb-3">${(module.type || 'Unknown').charAt(0).toUpperCase() + (module.type || 'Unknown').slice(1)} Module:</h5>
                        <div class="row">
                            <div class="col-md-6">
                                <h6>Module Information</h6>
                                <ul class="list-unstyled">
                                    <li><strong>Module ID:</strong> ${module.id || 'Unknown'}</li>
                                    <li><strong>Schema URL:</strong> ${module.schema_url || 'Unknown'}</li>
                                    <li><strong>Created:</strong> ${formatDate(module.created_at) || 'Unknown'}</li>
                                </ul>
                            </div>
                            <div class="col-md-6">
                                <h6>Metadata</h6>
                                <pre class="bg-light p-2 rounded" style="max-height: 200px; overflow-y: auto;">${JSON.stringify(module.metadata || {}, null, 2)}</pre>
                            </div>
                        </div>
                        
                        <div class="mt-3">
                            ${(() => {
                                console.log('Module type:', module.type, 'Type of:', typeof module.type);
                                const isImageModule = module.type && (
                                    module.type.toLowerCase().includes('image') || 
                                    module.type.toLowerCase().includes('dicom') ||
                                    module.type.toLowerCase().includes('imaging') ||
                                    module.type.toLowerCase().includes('pixel')
                                );
                                console.log('Is image module:', isImageModule);
                                return isImageModule ? 
                                    `<h6>Image Viewer</h6>
                                    <div class="text-center p-4 bg-light rounded">
                                        <div class="d-flex align-items-start justify-content-center">
                                            <div class="image-viewer-container me-3" style="display: inline-block; border: 2px solid #dee2e6; border-radius: 8px; overflow: hidden; background: linear-gradient(45deg, #f8f9fa 25%, transparent 25%), linear-gradient(-45deg, #f8f9fa 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #f8f9fa 75%), linear-gradient(-45deg, transparent 75%, #f8f9fa 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;">
                                                <div class="image-placeholder" style="display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 14px; min-width: 200px; min-height: 150px; ${getImageViewerStyle(module.data, module.metadata)}">
                                                    <div class="text-center">
                                                        <i class="fas fa-image fa-2x mb-2"></i>
                                                        <p class="mb-1">Image viewer will be implemented here</p>
                                                        ${(() => {
                                                            const imageInfo = getImageInfo(module.data, module.metadata);
                                                            return `
                                                                <p class="small mb-1">Dimensions: ${imageInfo.dimensions}</p>
                                                                <p class="small mb-1">Number of Dimensions: ${imageInfo.numDimensions}</p>
                                                                <p class="small">Number of Frames: ${imageInfo.numFrames}</p>
                                                            `;
                                                        })()}
                                                    </div>
                                                </div>
                                            </div>
                                            ${(() => {
                                                const imageInfo = getImageInfo(module.data, module.metadata);
                                                if (imageInfo.numDimensions <= 2) return '';
                                                
                                                // Get the additional dimensions (skip first two which are width and height)
                                                let additionalDims = [];
                                                if (module.metadata && module.metadata.dimensions && Array.isArray(module.metadata.dimensions)) {
                                                    additionalDims = module.metadata.dimensions.slice(2);
                                                } else if (module.data && module.data.dimensions && Array.isArray(module.data.dimensions)) {
                                                    additionalDims = module.data.dimensions.slice(2);
                                                } else if (module.data && module.data.size && Array.isArray(module.data.size)) {
                                                    additionalDims = module.data.size.slice(2);
                                                }
                                                
                                                if (additionalDims.length === 0) return '';
                                                
                                                // Create sliders for each additional dimension
                                                const sliderHtml = additionalDims.map((dim, index) => {
                                                    // Get dimension names from metadata, fallback to generic names
                                                    const dimensionNames = module.metadata?.dimension_names || 
                                                                         module.data?.dimension_names || 
                                                                         ['Slice', 'Time', 'Channel', 'Phase', 'Echo'];
                                                    // Use the same index as the dimensions array (index + 2 since we're starting from the 3rd dimension)
                                                    const dimName = dimensionNames[index + 2] || `Dimension ${index + 3}`;
                                                    return `
                                                        <div class="mb-4 d-flex align-items-center">
                                                            <div class="me-4" style="min-width: 80px;">
                                                                <label class="form-label small mb-0">${dimName}:</label>
                                                            </div>
                                                            <div class="me-4">
                                                                <span class="badge bg-secondary">0-${dim - 1}</span>
                                                            </div>
                                                            <div class="custom-slider me-4" data-dimension="${index + 2}" data-module-id="${module.id || 'unknown'}">
                                                                <div class="slider-track">
                                                                    <div class="slider-fill" style="width: 0%"></div>
                                                                    <div class="slider-thumb" style="left: 0%"></div>
                                                                </div>
                                                                <input type="hidden" class="slider-value" value="0" min="0" max="${dim - 1}">
                                                            </div>
                                                            <div class="small text-muted" style="min-width: 80px;">
                                                                Current: <span class="current-value">0</span>
                                                            </div>
                                                        </div>
                                                    `;
                                                }).join('');
                                                
                                                return `
                                                    <div class="dimension-controls" style="min-width: 150px;">
                                                        <h6 class="small mb-2">Dimension Controls</h6>
                                                        ${sliderHtml}
                                                    </div>
                                                `;
                                            })()}
                                        </div>
                                        <p class="small text-muted mt-2">Module Type: ${module.type}</p>
                                    </div>` 
                                    : 
                                    `<h6>Module Data</h6>
                                    <pre class="bg-light p-2 rounded" style="max-height: 300px; overflow-y: auto;">${JSON.stringify(module.data || {}, null, 2)}</pre>`;
                            })()}
                        </div>
                    </div>
                </div>
            `;
            modulesContainer.appendChild(moduleCard);
        });
        
        // Insert modules right after the file info header card, maintaining the same column structure
        const fileInfoRow = document.querySelector('.row.mb-4');
        if (fileInfoRow) {
            fileInfoRow.parentElement.appendChild(modulesContainer);
        } else {
            // Fallback to main container
            const container = document.querySelector('.container-fluid');
            container.appendChild(modulesContainer);
        }
        
        if (isNewImport) {
            showSuccess(`File processed successfully! Found ${data.module_count} modules.`);
        }
    } else {
        if (isNewImport) {
            showSuccess('File processed successfully, but no modules were found.');
        }
    }
}

function getImageDimensions(moduleData, moduleMetadata) {
    if (!moduleData && !moduleMetadata) return 'Unknown';
    
    try {
        // First try to get dimensions from metadata
        if (moduleMetadata && moduleMetadata.dimensions) {
            const dims = moduleMetadata.dimensions;
            if (Array.isArray(dims) && dims.length >= 2) {
                return `${dims[0]} × ${dims[1]}`;
            }
            if (typeof dims === 'object' && dims.width && dims.height) {
                return `${dims.width} × ${dims.height}`;
            }
        }
        
        // Fallback to module data if metadata doesn't have dimensions
        if (moduleData) {
            if (moduleData.width && moduleData.height) {
                return `${moduleData.width} × ${moduleData.height}`;
            }
            if (moduleData.dimensions) {
                const dims = moduleData.dimensions;
                if (Array.isArray(dims) && dims.length >= 2) {
                    return `${dims[0]} × ${dims[1]}`;
                }
                if (typeof dims === 'object' && dims.width && dims.height) {
                    return `${dims.width} × ${dims.height}`;
                }
            }
            if (moduleData.rows && moduleData.columns) {
                return `${moduleData.columns} × ${moduleData.rows}`;
            }
            if (moduleData.size && Array.isArray(moduleData.size)) {
                return `${moduleData.size[0] || '?'} × ${moduleData.size[1] || '?'}`;
            }
        }
        
        return 'Unknown dimensions';
    } catch (e) {
        return 'Error reading dimensions';
    }
}

function getImageInfo(moduleData, moduleMetadata) {
    if (!moduleData && !moduleMetadata) return { dimensions: 'Unknown', numDimensions: 0, numFrames: 0 };
    
    try {
        let dimensions = 'Unknown';
        let numDimensions = 0;
        let numFrames = 0;
        
        console.log('Calculating image info for:', { moduleData, moduleMetadata });
        
        // First try to get dimensions from metadata
        if (moduleMetadata && moduleMetadata.dimensions) {
            const dims = moduleMetadata.dimensions;
            console.log('Found dimensions in metadata:', dims);
            if (Array.isArray(dims)) {
                numDimensions = dims.length;
                if (dims.length >= 2) {
                    dimensions = `${dims[0]} × ${dims[1]}`;
                    if (dims.length === 2) {
                        // 2D image - only 1 frame
                        numFrames = 1;
                    } else {
                        // 3D+ image - calculate frames from additional dimensions
                        // First two dimensions are width and height, rest contribute to frame count
                        numFrames = 1;
                        for (let i = 2; i < dims.length; i++) {
                            numFrames *= dims[i];
                        }
                    }
                }
            } else if (typeof dims === 'object' && dims.width && dims.height) {
                dimensions = `${dims.width} × ${dims.height}`;
                numDimensions = 2;
                numFrames = 1;
            }
        }
        
        // Fallback to module data if metadata doesn't have dimensions
        if (numDimensions === 0 && moduleData) {
            console.log('Checking module data for dimensions');
            if (moduleData.width && moduleData.height) {
                dimensions = `${moduleData.width} × ${moduleData.height}`;
                numDimensions = 2;
                numFrames = 1;
            } else if (moduleData.dimensions) {
                const dims = moduleData.dimensions;
                console.log('Found dimensions in module data:', dims);
                if (Array.isArray(dims)) {
                    numDimensions = dims.length;
                    if (dims.length >= 2) {
                        dimensions = `${dims[0]} × ${dims[1]}`;
                        if (dims.length === 2) {
                            numFrames = 1;
                        } else {
                            numFrames = 1;
                            for (let i = 2; i < dims.length; i++) {
                                numFrames *= dims[i];
                            }
                        }
                    }
                } else if (typeof dims === 'object' && dims.width && dims.height) {
                    dimensions = `${dims.width} × ${dims.height}`;
                    numDimensions = 2;
                    numFrames = 1;
                }
            } else if (moduleData.rows && moduleData.columns) {
                dimensions = `${moduleData.columns} × ${moduleData.rows}`;
                numDimensions = 2;
                numFrames = 1;
            } else if (moduleData.size && Array.isArray(moduleData.size)) {
                numDimensions = moduleData.size.length;
                if (moduleData.size.length >= 2) {
                    dimensions = `${moduleData.size[0] || '?'} × ${moduleData.size[1] || '?'}`;
                    if (moduleData.size.length === 2) {
                        numFrames = 1;
                    } else {
                        numFrames = 1;
                        for (let i = 2; i < moduleData.size.length; i++) {
                            numFrames *= moduleData.size[i];
                        }
                    }
                }
            }
        }
        
        const result = { dimensions, numDimensions, numFrames };
        console.log('Image info calculation result:', result);
        return result;
    } catch (e) {
        console.error('Error calculating image info:', e);
        return { dimensions: 'Error reading dimensions', numDimensions: 0, numFrames: 0 };
    }
}

function getImageViewerStyle(moduleData, moduleMetadata) {
    try {
        // First try to get dimensions from metadata
        let width, height;
        
        if (moduleMetadata && moduleMetadata.dimensions) {
            const dims = moduleMetadata.dimensions;
            if (Array.isArray(dims) && dims.length >= 2) {
                width = dims[0];
                height = dims[1];
            } else if (typeof dims === 'object' && dims.width && dims.height) {
                width = dims.width;
                height = dims.height;
            }
        }
        
        // Fallback to module data if metadata doesn't have dimensions
        if (!width || !height) {
            if (moduleData && moduleData.width && moduleData.height) {
                width = moduleData.width;
                height = moduleData.height;
            } else if (moduleData && moduleData.dimensions) {
                const dims = moduleData.dimensions;
                if (Array.isArray(dims) && dims.length >= 2) {
                    width = dims[0];
                    height = dims[1];
                } else if (typeof dims === 'object' && dims.width && dims.height) {
                    width = dims.width;
                    height = dims.height;
                }
            }
        }
        
        if (width && height) {
            // Scale down dimensions to fit nicely in the UI (max 400px for the larger dimension)
            const maxSize = 400;
            const scale = Math.min(maxSize / Math.max(width, height), 1);
            const scaledWidth = Math.round(width * scale);
            const scaledHeight = Math.round(height * scale);
            
            return `width: ${scaledWidth}px; height: ${scaledHeight}px;`;
        }
        
        return '';
    } catch (e) {
        console.error('Error calculating image viewer style:', e);
        return '';
    }
}

function formatDate(dateString) {
    if (!dateString) return 'Unknown';
    
    try {
        const date = new Date(dateString);
        if (isNaN(date.getTime())) return 'Invalid Date';
        
        return date.toLocaleDateString('en-GB', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    } catch (e) {
        return 'Invalid Date';
    }
}

function showSuccess(message) {
    const successDiv = document.createElement('div');
    successDiv.className = 'alert alert-success';
    successDiv.innerHTML = `<i class="fas fa-check-circle me-2"></i>${message}`;
    
    successDiv.style.position = 'fixed';
    successDiv.style.bottom = '20px';
    successDiv.style.left = '50%';
    successDiv.style.transform = 'translateX(-50%)';
    successDiv.style.zIndex = '9999';
    successDiv.style.minWidth = '300px';
    successDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
    successDiv.style.borderRadius = '8px';
    successDiv.style.transition = 'opacity 0.5s ease-out'; // Added for fade-out
    
    document.body.appendChild(successDiv);
    
    // Start fade out after 1.5 seconds
    setTimeout(() => {
        successDiv.style.opacity = '0';
        
        // Remove from DOM after fade completes
        setTimeout(() => {
            if (successDiv.parentNode) {
                successDiv.parentNode.removeChild(successDiv);
            }
        }, 500); // 0.5s for fade transition
    }, 1500); // 1.5s visible time
}

function showError(message) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'alert alert-danger';
    errorDiv.innerHTML = `<i class="fas fa-exclamation-circle me-2"></i>${message}`;
    
    errorDiv.style.position = 'fixed';
    errorDiv.style.bottom = '20px';
    errorDiv.style.left = '50%';
    errorDiv.style.transform = 'translateX(-50%)';
    errorDiv.style.zIndex = '9999';
    errorDiv.style.minWidth = '300px';
    errorDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
    errorDiv.style.borderRadius = '8px';
    errorDiv.style.transition = 'opacity 0.5s ease-out';
    
    document.body.appendChild(errorDiv);
    
    // Start fade out after 2 seconds
    setTimeout(() => {
        errorDiv.style.opacity = '0';
        
        // Remove from DOM after fade completes
        setTimeout(() => {
            if (errorDiv.parentNode) {
                errorDiv.parentNode.removeChild(errorDiv);
            }
        }, 500); // 0.5s for fade transition
    }, 2000); // 2s visible time
}

function clearFileCache() {
    localStorage.removeItem('umdf_file_data');
    sessionStorage.removeItem('file_id'); // Clear session storage for the current file
    window.location.reload(); // Reload the page to show "No file loaded"
    showSuccess('File cache cleared. Please import a new file.');
}

function importNewFile() {
    // Redirect back to the home page to import a new file
    window.location.href = '/';
}

// Add event listeners for dimension sliders
function setupDimensionSliders() {
    // Use event delegation to handle sliders that are dynamically created
    document.addEventListener('input', function(event) {
        if (event.target.type === 'range' && event.target.hasAttribute('data-dimension')) {
            const slider = event.target;
            const dimension = parseInt(slider.getAttribute('data-dimension'));
            const moduleId = slider.getAttribute('data-module-id');
            const value = parseInt(slider.value);
            
            // Update the current value display
            const currentValueSpan = slider.parentNode.querySelector('.current-value');
            if (currentValueSpan) {
                currentValueSpan.textContent = value;
            }
            
            // Log the dimension change (this is where you'd update the image display)
            console.log(`Module ${moduleId}: Dimension ${dimension} changed to ${value}`);
            
            // TODO: Update the image display based on the selected dimensions
            // This would involve:
            // 1. Getting the current values from all sliders
            // 2. Calculating the frame index based on the selected dimensions
            // 3. Updating the image viewer to show the selected frame
            updateImageDisplay(moduleId, dimension, value);
        }
    });
}

function updateImageDisplay(moduleId, dimension, value) {
    // This function will be called whenever a slider changes
    // For now, just log the change - you can implement the actual image update logic here
    
    // Get all sliders for this module
    const moduleSliders = document.querySelectorAll(`[data-module-id="${moduleId}"]`);
    const currentValues = {};
    
    // Collect current values from all sliders
    moduleSliders.forEach(slider => {
        const dim = parseInt(slider.getAttribute('data-dimension'));
        currentValues[dim] = parseInt(slider.value);
    });
    
    console.log(`Updating image display for module ${moduleId}:`, currentValues);
    
    // TODO: Implement the actual image frame selection logic
    // This would involve:
    // 1. Calculating the frame index from the dimension values
    // 2. Fetching the corresponding image data from the module
    // 3. Updating the image viewer to display the selected frame
}

// Initialize sliders when the page loads
document.addEventListener('DOMContentLoaded', function() {
    setupDimensionSliders();
});

        // Event delegation for custom sliders
        document.addEventListener('click', function(e) {
            if (e.target.closest('.slider-track')) {
                const slider = e.target.closest('.custom-slider');
                const track = slider.querySelector('.slider-track');
                const thumb = slider.querySelector('.slider-thumb');
                const fill = slider.querySelector('.slider-fill');
                const valueInput = slider.querySelector('.slider-value');
                const currentValueSpan = slider.closest('.d-flex').querySelector('.current-value');
                
                const rect = track.getBoundingClientRect();
                const clickX = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
                const percentage = (clickX / rect.width) * 100;
                
                // Update visual elements with precise positioning
                thumb.style.left = percentage + '%';
                fill.style.width = percentage + '%';
                
                // Calculate and update value with proper rounding
                const min = parseInt(valueInput.getAttribute('min'));
                const max = parseInt(valueInput.getAttribute('max'));
                const value = Math.round(min + (percentage / 100) * (max - min));
                valueInput.value = value;
                currentValueSpan.textContent = value;
                
                // Trigger update function
                const moduleId = slider.getAttribute('data-module-id');
                const dimension = parseInt(slider.getAttribute('data-dimension'));
                updateImageDisplay(moduleId, dimension, value);
            }
        });
        
        // Drag functionality for sliders
        document.addEventListener('mousedown', function(e) {
            if (e.target.closest('.slider-thumb')) {
                const thumb = e.target.closest('.slider-thumb');
                const slider = thumb.closest('.custom-slider');
                const track = slider.querySelector('.slider-track');
                const fill = slider.querySelector('.slider-fill');
                const valueInput = slider.querySelector('.slider-value');
                const currentValueSpan = slider.closest('.d-flex').querySelector('.current-value');
                
                let isDragging = true;
                
                // Disable transitions during drag for instant response
                thumb.style.transition = 'none';
                fill.style.transition = 'none';
                
                function onMouseMove(e) {
                    if (!isDragging) return;
                    
                    const rect = track.getBoundingClientRect();
                    const mouseX = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
                    const percentage = (mouseX / rect.width) * 100;
                    
                    // Update visual elements with precise positioning
                    thumb.style.left = percentage + '%';
                    fill.style.width = percentage + '%';
                    
                    // Calculate and update value with proper rounding
                    const min = parseInt(valueInput.getAttribute('min'));
                    const max = parseInt(valueInput.getAttribute('max'));
                    const value = Math.round(min + (percentage / 100) * (max - min));
                    valueInput.value = value;
                    currentValueSpan.textContent = value;
                    
                    // Trigger update function
                    const moduleId = slider.getAttribute('data-module-id');
                    const dimension = parseInt(slider.getAttribute('data-dimension'));
                    updateImageDisplay(moduleId, dimension, value);
                }
                
                function onMouseUp() {
                    isDragging = false;
                    
                    // Re-enable transitions after drag for smooth hover effects
                    thumb.style.transition = '';
                    fill.style.transition = '';
                    
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
        });
</script>
{% endblock %} 